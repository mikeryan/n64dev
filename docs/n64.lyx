#LyX 1.5.5 created this file. For more info see http://www.lyx.org/
\lyxformat 276
\begin_document
\begin_header
\textclass article
\language english
\inputencoding auto
\font_roman palatino
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\paperfontsize 12
\spacing single
\papersize letterpaper
\use_geometry false
\use_amsmath 1
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Embedded MIPS Development with the Nintendo 64
\end_layout

\begin_layout Author
Ryan Underwood
\end_layout

\begin_layout Abstract
Using Nintendo's 64-bit console, we explore the intricacies and design decisions
 involved in developing software for a console or embedded platform.
 
\series bold
This is a work in progress!
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Paragraph
Embedded development, while drastically simplified compared to systems programmi
ng for a general purpose platform, presents many challenges to attain a
 superior product at minimal cost.
 The first set of challenges we can identify are purely physical.
 Obviously, the speed of the CPU and the size of memory are the two main
 decisions that impact the cost per unit.
 Also necessary to consider is what user interface is desired, and the appropria
te I/O hardware to accomodate each aspect of the interface.
 Size must be considered, not only in terms of material cost; who wants
 to lug around a bulky digital music player? Power consumption is critical;
 it presents a three-pronged blade to threaten effective platform design.
 The first issue is simply the rate at which the system consumes power.
 This is a problem especially for battery-powered devices, but extends as
 a problem of scalability too; greater power consumption simply means greater
 operating cost to the end user and thus a lesser value assigned to the
 product.
 Power consumption is determined by the components selected for the platform,
 as well as how software chooses to utilize those components.
 The second issue is the heat that is dissipated by the switching of silicon
 gates.
 Excessive heat generation produces undesirable traits for the user, and
 can also lead to premature component failures.
 Usually, power consumption and heat dissipation of a system are strongly
 linked, and frequently result from a hardware design strategy that is excessive
 in nature.
 The last issue is that of reliability.
 Designs which employ a high rate of power consumption must have safety
 features such as filters scattered throughout the system to prevent erroneous
 behavior under load, and require higher or tighter component tolerances
 in areas such as the power supply.
 All this leads to extra design time, more potential sources of design error,
 and extra unit cost.
\end_layout

\begin_layout Paragraph
Among other factors, the number of components and their complexity affect
 size and power consumption the most.
 Therefore, the hardware designer is faced with a difficult tradeoff.
 Essentially, he must select which features of a general purpose computing
 platform must be omitted in his embedded platform in order to reduce costs,
 while allowing the features that will provide the user with the most value
 to remain.
 What makes this decision even more difficult is that knowing which features
 will provide the most value requires knowledge of how software designers
 will make use of the platform.
 Frequently, the wrong features are cut and less important features remain,
 incurring unnecessary cost on the manufacturer and thwarting attempts at
 elegant software design.
\end_layout

\begin_layout Paragraph
The focus of this text is on software development where the hardware platform
 is a given.
 Targeting a fixed and known hardware platform fits well with development
 for set-top boxes or game consoles, but also with the rising popularity
 of single-board computers and System-On-a-Chip (SOC) solutions.
 In this paradigm, the hardware is mass produced so that it may be sold
 at a very low cost, and individual providers develop the software to run
 on the mass produced platform.
 The hardware/software combination together completes the product that is
 to be shipped to end users.
\end_layout

\begin_layout Paragraph
Our focus is on development for a game console, the Nintendo 64 (heretoafter
 referred to as Ultra 64 or N64), which had a multi-year mass market lifespan.
 Consequently, the install base is very large and consists of primarily
 users who purchased the console to be able to use game software designed
 for it.
 The knowledge we gain in developing a software platform for this console
 can be extended to embedded development in general; the only difference
 is that in an embedded product, the platform and its software are designed
 to be inseparable.
 If the N64 were an embedded platform, it would have shipped with the program
 cartridge moulded to the console.
\end_layout

\begin_layout Section
Taking Stock of the Hardware
\end_layout

\begin_layout Paragraph
As software designers, we will be working intimately with our chosen hardware
 platform.
 Therefore, it is essential to know with as much precision as possible what
 the details of our hardware architecture are.
 Sometimes hardware manufacturers or licensed third parties offer complete
 SDKs (Software Development Kits) for their platforms that ease the bootstrappin
g of a project; usually an experienced C programmer will be able to make
 use of a SDK to drastically cut down time-to-market.
 However, the SDK usually contains proprietary information obtained or developed
 at cost to the platform designer, which manifests itself to the software
 developer as a per-unit licensing fee or the unavailability of source code.
 (See Section 3 for more information on SDKs).
 For this discussion, we will focus on developing software solutions without
 a third-party SDK, and on developing our own SDK to use in-house or to
 license to third parties.
\end_layout

\begin_layout Paragraph
The information we need to know about our platform boils down to three categorie
s:
\end_layout

\begin_layout Enumerate
How to program the processor(s)
\end_layout

\begin_layout Enumerate
How to program peripherals
\end_layout

\begin_layout Enumerate
How to execute our code on the target
\end_layout

\begin_layout Paragraph
This information can be gleaned (rarely) from marketing materials, or more
 usually a designer's handbook.
 In a limited fashion, it can also be derived from observation or from reverse
 engineering.
\end_layout

\begin_layout Paragraph
The N64's hardware features are as follows:
\end_layout

\begin_layout Itemize
MIPS R4300i RISC 64-bit embedded processor, 93.75 MHz
\end_layout

\begin_layout Itemize
Reality CoProcessor (RCP), 62.5 MHz
\end_layout

\begin_layout Itemize
4MB Rambus RDRAM (8MB with memory expansion)
\end_layout

\begin_layout Itemize
4 peripheral ports
\end_layout

\begin_layout Itemize
Cartridge/system bus interface
\end_layout

\begin_layout Standard
<FIXME block diagram>
\end_layout

\begin_layout Paragraph
MIPS provides a public specification for the MIPS IV instruction set as
 well as the R4300i processor specifically.
 Therefore, programming this processor should be no problem, assuming no
 customization has been made to it.
\end_layout

\begin_layout Paragraph
The rest of the system is documented only privately, in the Nintendo SDK
 HTML manuals and 'man' pages.
 These are available to SDK licensees only.
 Furthermore, these documents typically only cover the Nintendo SDK operating
 system interfaces, and do not go into much detail about the underlying
 software<->hardware interface.
 Information about the rest of the system has been derived by members of
 the 
\begin_inset LatexCommand url
name "Dextrose"
target "http://www.dextrose.com"

\end_inset

 group and message board, by N64 emulator authors, by many unnamed and defunct
 groups around the globe, and by commercial interests who develop unofficial
 N64 development platforms to be sold at a much lower cost than the official
 ones.
 Through the efforts of these disparate (and only occasionally cooperating)
 groups, unofficial programming information for nearly all of the N64's
 peripherals, its coprocessor, and its memory/register map have been produced.
 Nintendo is unable to claim any intellectual property rights on this independen
tly derived information, so we use it freely in this document.
 We use symbolic constant names compatible with the official SDK, so that
 individuals already familiar with the SDK can more easily follow along.
\end_layout

\begin_layout Standard
FIXME: note Sega vs Accolade, Nintendo v Tengen court cases regarding hardware
 lock-outs.
\end_layout

\begin_layout Subsection
Programming the N64 CPU
\end_layout

\begin_layout Paragraph
The NEC R4300i implements the MIPS III instruction set.
 The CPU runs at 93.75 MHz PClock (MasterClock*1.5) and can be switched at
 runtime between 32-bit and 64-bit addressing.
 It can execute one instruction per clock cycle and has a 5-stage pipeline.
 It has a 16KB instruction cache and a 8KB write-back data cache (both non-parit
y).
 At this clock speed, it attains 125 MIPS and a score of 60/45 on SPECint/fp92.
 It has fixed-width instructions and clearly defined coprocessor interfaces.
 The N64 CPU is configured to run in big-endian mode.
\end_layout

\begin_layout Subsubsection
Addressing and Cacheability
\end_layout

\begin_layout Paragraph
The CPU has three modes of execution according to the R4300 datasheet: kernel,
 supervisor, and user mode.
 Since we are in complete control of the machine, we will exclusively be
 operating in kernel mode.
 (If we were writing a general purpose operating system, we would implement
 the operating system in kernel mode, and processes would be executed in
 user mode.
 kseg0 and kseg1 would be inaccessible in user mode.) We will also use 32-bit
 addressing instead of 64-bit; since the N64 is limited to 8 megabytes of
 system memory, 64-bit pointers gain us no benefit on this platform.
\end_layout

\begin_layout Paragraph
An important effect of the mode of the processor is in determining the system's
 memory map.
 According to the R4300 datasheet, there are five regions of memory when
 in Kernel mode:
\end_layout

\begin_layout Itemize
0x00000000-0x7FFFFFFF: kuseg (TLB-mapped 2G physical)
\end_layout

\begin_layout Itemize
0x80000000-0x9FFFFFFF: kseg0 (direct-mapped 512MB, cached)
\end_layout

\begin_layout Itemize
0xA0000000-0xBFFFFFFF: kseg1 (direct-mapped 512MB, uncached)
\end_layout

\begin_layout Itemize
0xC0000000-0xDFFFFFFF: ksseg (TLB-mapped)
\end_layout

\begin_layout Itemize
0xE0000000-0xFFFFFFFF: kseg3 (TLB-mapped)
\end_layout

\begin_layout Paragraph
We are concerned mainly with the first three regions.
 The power-on configuration causes the physical memory of the N64 to be
 repeated in kuseg, kseg0, and kseg1.
 The access characteristics differ, however.
 The only difference we are concerned with between kuseg and kseg0 is that
 kuseg is accessed through the CPU's TLB (translation lookaside buffer).
 This can incur a performance penalty.
 Since we do not need more than a 512MB virtual address space on the N64,
 we will use kseg0 instead of kuseg under almost all conditions.
 kseg1 is useful because occasionally bypassing the CPU's cache is desirable.
 With some exceptions, usually we will use the following guidelines for
 selecting memory regions:
\end_layout

\begin_layout Itemize
Use kseg0 for general programming and especially when high performance is
 required.
\end_layout

\begin_layout Itemize
Use kseg1 when accessing hardware registers and external memories, and when
 writing data intended to be picked up by peripheral DMA.
\end_layout

\begin_layout Paragraph
If we write to a cached region (kseg0), we must always remember to flush
 the CPU data cache before using that memory for operations in the RCP or
 other peripherals; when peripherals are programmed to perform DMA reads,
 they will always access the uncached version of the data directly from
 memory.
 Also, when a peripheral performs a DMA write to memory, we need to invalidate
 the CPU cache for that region to ensure that a subsequent CPU cache flush
 doesn't overwrite any data fetched from the peripheral.
\end_layout

\begin_layout Paragraph
It is possible to disable the kseg0 caching to aid in debugging.
 See section 
\begin_inset LatexCommand ref
reference "sub:Programming-the-RCP"

\end_inset

 for more information.
\end_layout

\begin_layout Paragraph
Remember that if the low 29 bits of two addresses are identical, their physical
 location is identical.
 Changing the upper four bits only changes the CPU's access strategy (cached/unc
ached and TLB-mapped or direct-mapped).
 For example, the PIF-ROM can be found at two seemingly different locations
 -- 0x1FC00000 and 0xBFC00000.
 Using the knowledge we just gained, we realize that these two locations
 are actually one and the same, because the low-order 29 bits in the two
 addresses are identical.
 One difference is that accessing the PIF-ROM through 0x1FC00000 uses the
 TLB, and accessing it through 0xBFC00000 does not require any address translati
on.
 The other difference is that accessing it through 0xBFC00000 bypasses the
 CPU's data cache, whereas 0x1FC00000 is always a cached access (unless
 we have previously invalidated the CPU data cache for that address, or
 have disabled the TLB cache bit for that region).
\end_layout

\begin_layout Paragraph
When describing hardware addresses, the preferred region to access whatever
 unit is being described will be given.
 Do not infer, however, that the given address is the only method of access.
 Indeed, under some circumstances, we will find ourselves forced to use
 unconventional procedure, to work around performance problems or unexpected
 hardware interactions.
 Use whatever addressing scheme is best for the particular unit of code
 under question.
\end_layout

\begin_layout Subsubsection
Delay Slots
\end_layout

\begin_layout Paragraph
For the highest performing code, we must observe the necessity of delay
 slots on the MIPS architecture.
 Delay slots are required by the design in order to prevent pipeline stalls.
 A delay slot is specified when:
\end_layout

\begin_layout Itemize
A conditional branch is taken.
\newline
The instruction in the delay slot is executed,
 unless the branch instruction is a 
\begin_inset Quotes eld
\end_inset

Likely
\begin_inset Quotes erd
\end_inset

 branch.
\end_layout

\begin_layout Itemize
A register load is performed.
\newline
If the instruction in the delay slot is dependent
 on the register being loaded, an interlock condition occurs and the processor
 must stall while its pipeline is reloaded (5 clock cycles).
 In the case of a register load with a coprocessor source, the destination
 register is not filled until after the next instruction has executed! (There
 is no interlock on coprocessor loads.)
\end_layout

\begin_layout Paragraph*
Not observing the branch or load delay slots will cause a decline in performance
 or unwanted behavior.
 Not observing the coprocessor delay slots will cause unspecified behavior.
\end_layout

\begin_layout Subsubsection
Exception Handling
\end_layout

\begin_layout Paragraph
The MIPS reset/NMI vector is mapped at reset to 0xBFC00000 (0x1FC00000 in
 kuseg).
 As we will later see, the reset condition is always handled by an embedded
 ROM (PIF-ROM) in the N64 which manages the lockout lock-out chip.
 The vector can be changed later for purposes of NMI or soft-reset (generated
 by the Reset button on the console), but we can't do anything about a hard
 reset; the PIF-ROM will always be executed.
 (FIXME right?)
\end_layout

\begin_layout Paragraph
The general exception vector is at 0xBFC00380 when BEV is set (see section
 
\begin_inset LatexCommand ref
reference "sub:Programming-the-RCP"

\end_inset

), and can be used for all other purposes.
 When an exception condition is encountered, the address at 0xBFC00380 will
 be the target of a branch, and the machine state will be on the stack.
\end_layout

\begin_layout Subsubsection
Code Generation
\end_layout

\begin_layout Paragraph
Assembling MIPS instructions to binary can be performed using the GNU binutils
 package, configured for the mips or mips64 targets.
 32-bit MIPS code can be executed on the N64, but 64-bit code gives higher
 performance with calculations involving large values.
 We will later use the GNU C compiler to generate MIPS code, but it is much
 easier for now to simply build binutils (for the assembler) than to build
 a complete C/C++ toolchain.
 In addition, running a C program requires start-up code, which we have
 not developed yet, to initialize the hardware and stack pointer and to
 invoke main().
\end_layout

\begin_layout Subsection
\begin_inset LatexCommand label
name "sub:Programming-the-RCP"

\end_inset

Programming the RCP Coprocessor Unit
\end_layout

\begin_layout Paragraph
The RCP is implemented as a standard MIPS coprocessor (CP0 and CP1).
 Most of its interface sub-units (*I) can be accessed through memory mapped
 registers.
 It runs at 62.5 MHz (MasterClock) and is capable of 500MFlops at that speed.
 It is based on a .35 micron manufacturing process.
 It is responsible for virtual memory, exception handling, and floating
 point processing.
\end_layout

\begin_layout Paragraph
The various functional subunits of the RCP can be accessed through memory-mapped
 registers.
 The available subunits are:
\end_layout

\begin_layout Itemize
RAC (Rambus ASIC Cell)
\newline
A memory controller IP for the Rambus RDRAM system
 memory.
 This could be off-the-shelf depending on the design.
\end_layout

\begin_layout Itemize
RSP (Reality Signal Processor)
\newline
A custom RISC processor with vector operations.
 The N64 sends it microcode and a command list that the microcode interprets,
 to produce graphics commands for the RDP or sound output.
\end_layout

\begin_layout Itemize
RDP (Reality Display Processor)
\newline
The rasterizing engine of the N64.
 The RDP receives commands from the RSP or a memory buffer, and writes the
 generated image data to the N64's framebuffer memory.
\end_layout

\begin_layout Itemize
VI (Video Interface)
\newline
The N64's framebuffer interface.
 It displays the contents of the framebuffer on the external video display.
\end_layout

\begin_layout Itemize
AI (Audio Interface)
\newline
Plays digital audio samples via DMA.
\end_layout

\begin_layout Itemize
PI (Peripheral Interface)
\newline
Connects cartridges and external hardware units
 to the N64.
\end_layout

\begin_layout Itemize
MI (MIPS Interface)
\newline
A control interface for CPU-related functionality, such
 as masking interrupts or determining the source of an interrupt.
\end_layout

\begin_layout Itemize
RI (RDRAM Interface)
\newline
The RCP's interface to the RAC and RDRAM system memory.
\end_layout

\begin_layout Itemize
SI (Serial Interface)
\newline
Responsible for accessing devices connected to the
 controller ports.
\end_layout

\begin_layout Subsubsection
CP0 Registers
\end_layout

\begin_layout Paragraph
Here we list the CP0 registers that interest us.
 There are more, but the others deal with memory management (TLB), which
 we are not particularly concerned with unless we are writing an OS.
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
R9 (Count) Timer count register
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
R11 (Compare) Timer compare value register
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
R12 (SR) Status Register
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
R13 (Cause) Exception Cause
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
R14 (EPC) Exception Saved PC
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
R16 (Config) Config Register
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
R18 (WatchLo) address trap lower bits
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
R19 (WatchHi) address trap upper bits
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
R30 (ErrorEPC) Reset/NMI saved PC
\end_layout

\begin_layout List
\labelwidthstring 00.00.0000
RP - Reduced Power - Bit 27 On
\end_layout

\begin_layout Standard
FR - Floating-point Register - Bit 26 On
\end_layout

\begin_layout Standard
RE - Reverse Endian - Bit 25 On
\end_layout

\begin_layout Standard
BEV - Bootstrap Exception Vector - Bit 22 On
\end_layout

\begin_layout Standard
SR - Is set if Soft Reset/NMI occurred - Bit 20
\end_layout

\begin_layout Standard
KSU - Set to 00 for kernel mode - Bit 3-4
\end_layout

\begin_layout Standard
ERL - Is set if a CPU error occurred - Bit 2
\end_layout

\begin_layout Standard
EXL - Is set if an exception occurred - Bit 1
\newline
Read the cause register to
 figure out what happened
\end_layout

\begin_layout Standard
IE - Interrupt Enable - Bit 0 On
\end_layout

\begin_layout Standard
ErrorEPC register - Reset/NMI saved PC
\end_layout

\begin_layout Standard
EPC register - Exception saved PC
\end_layout

\begin_layout Standard
WatchHi/WatchLo registers to trap memory accesses
\end_layout

\begin_layout Standard
Config register -
\end_layout

\begin_layout Standard
EC - Bit 28-30 System Clock Ratio (1:1/110 1.5:1/111 2:1/000 3:1/001) readonly
\end_layout

\begin_layout Standard
BE - Bit 15 - Big Endian - 0 => LE, 1=> BE
\end_layout

\begin_layout Standard
K0 - bit 0-2 - 010 => noncacheable 011=>cacheable
\end_layout

\begin_layout Standard
Count register / Compare register / sets IP7 which causes
\end_layout

\begin_layout Standard
interrupt if IE / write to Compare to clear
\end_layout

\begin_layout Standard
Count increments at 1/2 PClock and rolls over.
\end_layout

\begin_layout Subsection
Programming the RSP (Reality Signal Processor)
\end_layout

\begin_layout Subsection
Programming the RDP (Reality Display Processor)
\end_layout

\begin_layout Standard
4KB Texture memory (one 32x32 RGBA texture)
\end_layout

\begin_layout Standard
Features:
\end_layout

\begin_layout Standard
Alpha Transparency (8-bit)
\end_layout

\begin_layout Standard
Anti-Aliasing
\end_layout

\begin_layout Standard
Bilinear/Trilinear Filtering/Interpolation (and Point Sampling)
\end_layout

\begin_layout Standard
Culling/Level of Detail Management
\end_layout

\begin_layout Standard
Dithering
\end_layout

\begin_layout Standard
Environment Mapping
\end_layout

\begin_layout Standard
Fog
\end_layout

\begin_layout Standard
Mipmapping
\end_layout

\begin_layout Standard
Perspective Correct Texture Mapping
\end_layout

\begin_layout Standard
Shading (Flat/Gourad)
\end_layout

\begin_layout Standard
Specular Reflection/Shiny Surfaces (Metal Mario)
\end_layout

\begin_layout Standard
Trilinear Mipmap Interpolation
\end_layout

\begin_layout Standard
Z-Buffering
\end_layout

\begin_layout Subsection
Interfacing System RAM
\end_layout

\begin_layout Paragraph
The Rambus RDRAM memory used in the N64 has a 128-bit interface to the RCP,
 and is capable of 562.5 MB/s bandwidth.
 It implements parity checking, so it should generate a NMI when a parity
 error is detected (FIXME right?).
 The RAM is mapped at 0x00000000, and 64MB of address space is reserved
 for it.
 However, only 63MB of this address space can be used for physical memory,
 since the last 1MB is reserved for the Rambus memory controller registers.
\end_layout

\begin_layout Subsubsection
Addressing
\end_layout

\begin_layout Paragraph
The N64 console ships with 4MB of memory onboard, and a Rambus terminator
 called a 
\begin_inset Quotes eld
\end_inset

Jumper Pak
\begin_inset Quotes erd
\end_inset

 is installed in the memory expansion slot.
 A 4MB upgrade can be purchased and installed for a total of 8MB system
 memory.
 The following maps can be used depending on the amount of memory installed:
\end_layout

\begin_layout Itemize
For 4MB memory, use 0x80000000-0x803FFFFF.
\end_layout

\begin_layout Itemize
For 8MB memory, use 0x80000000-0x807FFFFF.
\end_layout

\begin_layout Subsubsection
Memory Detection
\end_layout

\begin_layout Paragraph
To check how much memory is installed, we consult the address 0x80000318.
 It corresponds to osMemSize from the SDK, and contains the size of memory
 (0x00400000 for 4MB or 0x00800000 for 8MB).
 The PIF-ROM code detects the size of memory and sets the value at that
 address before jumping to program code.
 If we wish to detect the size of memory ourselves instead of using the
 value the PIF-ROM gave us, we can use the following algorithm:
\end_layout

\begin_layout Enumerate
Start at address (0x80400000 - 4) and a memory count of 4MB.
\end_layout

\begin_layout Enumerate
Write a 32-bit word to the address, read it back, and compare it to the
 value written.
\end_layout

\begin_layout Enumerate
If it is the same, add 0x100000 to the address and 1MB to the memory count.
\end_layout

\begin_layout Enumerate
Repeat until the memory count is equal to the desired amount of memory.
 If we are only verifying the existence of an official memory expansion,
 stop when the memory count is equal to 8MB.
\end_layout

\begin_layout Paragraph
Note that an attempt to access a non-existent physical memory address will
 result in an exception, so in order to prevent a CPU crash when performing
 memory detection, an appropriate general exception handler must be installed.
\end_layout

\begin_layout Subsubsection
Access Strategy
\end_layout

\begin_layout Paragraph
The N64's Rambus RDRAM system memory has a high bandwidth but trades latency
 for this bandwidth.
 Compared to the same speed SDRAM, accessing main memory in a scattered
 fashion is exceptionally slow.
 Also, since the memory controller is part of the RCP and can only be accessed
 through the RCP, the R4300 CPU may be locked out from accessing memory
 if the RCP is busy, causing program slowdown.
\end_layout

\begin_layout Paragraph
To avoid this latency, programs should be optimized in a fashion such that
 registers are utilized both for passing procedure parameters and for procedure
 temporary (stack) variables.
 Thanks to the MIPS architecture providing 32 64-bit general-purpose registers
 (GPR), there are ample registers to use for this purpose.
\end_layout

\begin_layout Paragraph
The 
\series medium
\emph on
n32
\series default
\emph default
 ABI developed by SGI
\begin_inset LatexCommand ref
reference "sub:64-Bit-Issues"

\end_inset

 leverages this advantage.
 When this ABI is employed, up to eight 64-bit words, whether integer, float,
 struct, or union members, are passed in registers.
 Any data in excess of the eight 64-bit words is then additionally passed
 on the stack.
 Inside a function, up to 18 integer registers minus the number of register-pass
ed integer arguments are available, and up to 26 floating-point registers
 minus the number of register-passed FP arguments are available, without
 allocating additional stack space in main memory for local temporary variables.
\end_layout

\begin_layout Paragraph
For this reason, it is a good idea to break up functions that make excessive
 use of local temporary variables into simpler functions.
 One must at the same time observe the limitations on register passing,
 so that data is not simply shuffled around in memory to call subfunctions,
 thus negating the optimization.
 If a number of registers are used by the caller and its callers, they will
 be saved to the stack before the call, even if the subfunction parameters
 fit into the allocated registers.
 For this reason, recursive functions and other algorithms with deep call
 graphs or high space complexity are memory-intensive and, all other things
 equal, are a poor choice for the N64.
\end_layout

\begin_layout Paragraph
When main memory must be read from or stored to, try to design programs
 such that it is accessed in bursts of contiguous reads or writes.
 This can be most easily accomplished by utilizing data structures of size
 64-bits or less that can be manipulated entirely in CPU registers, or by
 using DMA transfers back and forth to main memory when large amounts of
 data must be read or written.
 Do not read chunks of data from memory to then simply write to another
 memory location! This is what DMA is for.
\end_layout

\begin_layout Subsubsection
Configuration
\end_layout

\begin_layout Paragraph
The RDRAM memory controller (RAC) configuration registers are 32-bit words
 mapped starting at 0x03F00000.
 Usually these registers are configured by firmware.
\newline

\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="3">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Address
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Symbolic Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Description
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0xA3F00000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
RDRAM_CONFIG
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0xA3F00004
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
RDRAM_DEVICE_ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0xA3F00008
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
RDRAM_DELAY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0xA3F0000C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
RDRAM_MODE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0xA3F00010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
RDRAM_REF_INTERVAL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0xA3F00014
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
RDRAM_REF_ROW
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0xA3F00018
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
RDRAM_RAS_INTERVAL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0xA3F0001C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
RDRAM_MIN_INTERVAL
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0xA3F00020
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
RDRAM_ADDR_SELECT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0xA3F00024
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
RDRAM_DEVICE_MANUF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0xA3F00028-0xA3FFFFFF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Unknown/Unused
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
Programming the RI (RDRAM Interface)
\end_layout

\begin_layout Paragraph
These registers are located in the RCP and are of 32-bit width.
 Usually these registers are configured by firmware.
 The RI registers are mapped at 0x04700000.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="3">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Address
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Symbolic Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Description
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0xA4700000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
RI_MODE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0xA4700004
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
RI_CONFIG
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0xA4700008
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
RI_CURRENT_LOAD
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0xA470000C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
RI_SELECT
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0xA4700010
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
RI_REFRESH
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0xA4700014
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
RI_LATENCY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0xA4700018
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
RI_RERROR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
d0=>nack error, d1=>ack error
\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0xA470001C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
RI_WERROR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Write to this register to clear RI_RERROR.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection
Programming the MI (MIPS Interface)
\end_layout

\begin_layout Paragraph
This interface acts the 
\begin_inset Quotes eld
\end_inset

glue
\begin_inset Quotes erd
\end_inset

 between the CPU and the RCP.
 Its chief purpose is to determine the source of an interrupt.
 MI registers are mapped at 0x04300000.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features>
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" width="0">
<column alignment="center" valignment="top" leftline="true" rightline="true" width="0">
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Address
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Symbolic Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
Description
\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0xA4300000
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MI_MODE
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row topline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0xA4300004
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MI_VERSION
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0xA4300008
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MI_INTR
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
<row topline="true" bottomline="true">
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
0xA430000C
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Standard
MI_INTR_MASK
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Standard

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Paragraph
FIXME describe various interrupt sources and masks.
\end_layout

\begin_layout Subsection
Programming the VI (Video Interface)
\end_layout

\begin_layout Paragraph
The VI is the frame buffer interface for the N64.
 It controls the resolution, color depth, and physical characteristics of
 the video display.
 On each screen redraw, it is responsible for reading the contents of the
 display from a given region in system memory (the frame buffer) and updating
 the image on the monitor.
 Resolutions from 256x224 to 640x480 can be used with 16 or 32-bit color
 depth.
 (PAL systems can use a 768x576 resolution FIXME?) What about MPAL?
\end_layout

\begin_layout Standard
The VI's registers are mapped at 0x04400000.
\end_layout

\begin_layout Subsection
AI (Audio Interface)
\end_layout

\begin_layout Paragraph
This unit produces analog audio output from digital audio samples.
 It supports up to 48kHz samples and 4 to 16-bit sample resolution.
 It uses DMA to play samples directly from system memory.
 A sample can be queued for play while one is currently playing.
 Unfortunately there is no mixing of samples, so we must employ our own
 mixing routines.
 Typically, mixing of multiple PCM streams, as well as sound manipulation
 such as ADPCM decompression, wavetable synthesis, and special effects (Voice,
 Pitch Shifting, Gain and Pan, Reverb and Chorus) are performed by an RSP
 microcode task.
\end_layout

\begin_layout Subsection
PI (Peripheral Interface)
\end_layout

\begin_layout Paragraph
This can be used to attach program cartridges to the system, or to attach
 development or other peripheral devices.
 The serial data lines to the cartridge EEPROM and lockout chip run through
 it, as do the left and right audio outputs.
 It can be physically accessed both via the cartridge port on the top, or
 the 64DD port on the bottom.
 Accessing it is performed via DMA transfers to and from the kseg1 (physical)
 region.
 Does this have anything to do with SysAD?
\end_layout

\begin_layout Standard
(the PI bus calls for embedded address decodes inside the devices...)
\end_layout

\begin_layout Subsection
Programming the SI (Serial Interface)
\begin_inset LatexCommand label
name "sub:Programming-the-SI"

\end_inset


\end_layout

\begin_layout Subsection
Programming the PIF (Peripheral InterFace)
\end_layout

\begin_layout Paragraph
PIF-NUS (U6) has 2K of internal storage, divided between RAM and ROM.
 It is chiefly responsible for input device management.
 The 64-byte PIF-RAM can be used to examine the current state of input devices,
 and commands can be written there for the PIF to execute.
 In its ROM region, it stores a small bootstrap program (PIF-ROM) that the
 MIPS CPU's reset vector (0xBFC00000) is pointed to at power-on.
 The PIF-ROM also plays a role in the hardware lockout scheme and will be
 discussed at length in that section.
\end_layout

\begin_layout Paragraph
Don't confuse this with the PI which is also referred to as 
\begin_inset Quotes eld
\end_inset

Peripheral Interface
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Paragraph
The PIF memory map is as follows:
\end_layout

\begin_layout Itemize
0xBFC00000-0xBFC007BF: PIF-ROM
\end_layout

\begin_layout Itemize
0xBFC007C0-0xBFC007FF: PIF-RAM
\end_layout

\begin_layout Paragraph
To read or write to the PIF, the programmer will normally request a SI DMA
 transfer (described in section 
\begin_inset LatexCommand ref
reference "sub:Programming-the-SI"

\end_inset

).
 It is possible to read from and write to the PIF RAM directly, and in fact
 this is done by boot code.
 But, the PIF has concurrent access to this region, and reads or writes
 may thus produce an inconsistent state, especially if the process accessing
 the PIF RAM is managed by an operating system.
 A DMA transfer transfers the entire PIF RAM in one read or write, ensuring
 that the state of the data structures it contains remains consistent with
 respect to both the reader process and the PIF hardware.
\end_layout

\begin_layout Standard
7FC Read 0x80 ?
\end_layout

\begin_layout Standard
Write 0x10 ?
\end_layout

\begin_layout Subsection
Human Interface Devices
\end_layout

\begin_layout Standard
controller, rumble pak, can we use keyboard/mouse?
\end_layout

\begin_layout Subsection
Memory Devices
\end_layout

\begin_layout Standard
cart eeprom/4xeep/flash/sram
\end_layout

\begin_layout Standard
controller paks - paged (switching) vs linear.
 what does 
\begin_inset Quotes eld
\end_inset

page count
\begin_inset Quotes erd
\end_inset

 measure? 4X - 492 pages
\end_layout

\begin_layout Standard
how to program a 4X linear memory pak?
\end_layout

\begin_layout Standard
ds1/dx256 passthrough saversThe Z64 can only access the EEPROM and not the
 CIC chip (for they have the same data and clock lines, but a different
 chip select line).
\end_layout

\begin_layout Standard
SRAM/FlashRAM is on Cartridge Domain 2 Address 2
\end_layout

\begin_layout Subsection
Audio and Video Output
\end_layout

\begin_layout Subsection
lockout and Booting Considerations
\end_layout

\begin_layout Subsubsection
lockout hardware
\end_layout

\begin_layout Paragraph
PIF ROM ensures that the boot code has not been tampered with, according
 to magic values stored in the cartridge's lockout chip (CIC) manufactured
 by Nintendo.
 The boot code ensures that the program has not been tampered with according
 to the checksum in the cartridge header.
\end_layout

\begin_layout Paragraph
There are a few ways to work with this scheme.
 If the response from the lockout chip to the PIF chip can be cloned, then
 the PIF ROM check can be defeated and arbitrary cartridge hardware can
 be used.
 The stored program would still, however, have to satisfy the conditions
 of the PIF ROM code and PIF chip in order for it to be booted.
 This means that its boot code, as hashed by the PIF ROM code, must present
 a value to the PIF chip that it agrees with.
 The cloned lockout chip would then have to possess knowledge about the
 specific stored program in order to know what response the PIF chip is
 expecting.
 This scheme would cross a software-hardware boundary and as a result be
 very difficult to implement.
 The user could be expected to know which response his software requires
 and use e.g.
 a switch to select from among those available, but as new security chips
 are introduced, an FPGA configuration or a microcontroller firmware would
 have to be updated by the user, making this an expensive and support-heavy
 method.
\end_layout

\begin_layout Paragraph
If, on the other hand, the results of the PIF ROM algorithm for a given
 lockout chip can be cloned, a payload bootcode written for any lockout
 chip could be executed by a program loader, as long as the program loader
 itself is written for the specific lockout chip that is present.
 This is in fact precisely what a boot emulator does; see section 
\begin_inset LatexCommand ref
reference "sub:Boot-emulators"

\end_inset

.
 This solution is the most popular since a boot emulator is pure software
 that can be easily updated even by inexperienced users.
 Development devices which include a BIOS like the CD64 and Z64 even employ
 their own custom boot emulators as a standard feature.
 The boot emulator is written for the most common NUS-CIC-6102 lockout chip,
 and will successfully run a payload bootcode that is written for any lockout
 chip, as long as the boot emulator has prior knowledge of the results of
 the PIF ROM algorithm for that particular lockout chip.
\end_layout

\begin_layout Paragraph
Another variant on the boot emulator approach is possible.
 Since there is in practice a 1:1 mapping between lockout chips and cartridge
 boot code -- making such boot code de facto canonical -- and the start
 of program code is identical for any given boot code, it is possible that
 the machine state is always the same for any given lockout chip whenever
 its (canonical) boot code jumps to the program code.
 If this is the case, the machine state at that point can be captured, and
 when the boot emulator begins to execute the payload program, it would
 then simply restore the known machine state before jumping to the known
 start of payload program code, rather than mimicing the results of the
 PIF ROM algorithm and then executing the payload boot code.
 While novel, it is unclear how this approach would improve on the standard
 boot emulator approach.
 It would only be of use if there were some benefit found in not executing
 the payload boot code under some circumstance.
\end_layout

\begin_layout Subsubsection
PIF / Bootstrap ROM
\end_layout

\begin_layout Paragraph
The main task the PIF ROM performs is to ensure that a stored program is
 authorized for execution by the PIF chip.
 It performs a two-part verification procedure before jumping to the boot
 code.
\end_layout

\begin_layout Paragraph
The PIF ROM is located at 0xBFC00000, which is the reset vector for the
 R4300 CPU.
 $PC is immediately set to this value and the code is jumped to at power-on.
\end_layout

\begin_layout Paragraph
The first part of the PIF ROM procedure checks for bit 0x80 at PIF RAM offset
 $4C (probably to check if the PIF is finished resetting), then loads a
 word from PIF offset $7E4 in PIF RAM.
 (Bit 19 determines whether program memory is located at 0xB0000000 (normal),
 or at 0xA6000000 (N64DD?).
 It is then stored to $7E44 in RAM.
 Bit 18 is stored to location $7E54 in RAM (fixme: expansion pak?).
 The second byte is then stored to $7E50 in RAM; this byte is used to seed
 the bootcode's checksum.
 Bit 17 is stored to location $7E4C in RAM (fixme: expansion pak?).
 1 is stored to $7E48.
 A pointer to the function following $138 in PIF ROM is stored to location
 $7E5C in RAM.
 The low byte is multiplied by 0x6C078965, the low part taken and added
 to one, and this value used to seed the lockout algorithm.
 The initial values of s2, s1, and s0 are stored to $7E40, $7E3C, and $7E38
 respectively.
 The value at PIF RAM offset $4C is read, or'd with 0x10, and stored back
 once SI no longer shows busy I/O.)
\end_layout

\begin_layout Paragraph
The default values of $03,$0F,$FF,$FF are used for the PI timing registers
 RLS,PGS,PWD,LAT.
 It then reads the first four bytes from the cartridge and uses these values
 -- which are the same in all released commercial software, 80,37,12,40
 -- to set the permanent values of the PI timing registers, which are $40,
 $803712, $8037, and $803.
 It reads RDP_STATUS to check if RSP DMEM DMA shows busy (0x01), and if
 so, it repeatedly checks the pipe busy flag (0x20) until it is clear.
 It then uses programmed I/O to copy the memory range 0x40 until 0x1000
 from the cartridge (the program boot-code) to the same offsets in RSP data
 memory (DMEM).
\end_layout

\begin_layout Paragraph
Once the program boot-code is copied to memory, the lockout algorithm starts
 by considering offset $40 in RSP DMEM, which is the first byte of the program
 boot-code.
\end_layout

\begin_layout Standard
Subroutines:
\end_layout

\begin_layout Standard
$13C (hashing routine?)
\end_layout

\begin_layout Standard
$1e8 (main loop)
\end_layout

\begin_layout Standard
$380 should be MIPS exception vector, but it is the middle of a routine.
\end_layout

\begin_layout Standard
$550 (multu(x, y, *hi, *lo) routine
\end_layout

\begin_layout Standard
$56C (
\begin_inset Quotes eld
\end_inset

returns
\begin_inset Quotes erd
\end_inset

 to bootcode in RSP DMEM)
\end_layout

\begin_layout Paragraph
When the algorithm is finished running over the program boot-code, then
 the CPU registers are loaded with the results as well as a byte from the
 PIF RAM and a function pointer into PIF ROM offset $138 (sub $13C).
 An output word from the algorithm is stored to PIF RAM offset $30, 5 cycles
 are waited and SI is quiesced, a reply word is loaded from PIF RAM offset
 $3C, a second output word from the algorithm is stored to PIF RAM offset
 $34, SI is quiesced, the second word is or'd with $20 and stored to PIF
 RAM offset $4C, then a delay is executed with a periodic check for bit
 $80 at PIF RAM offset $4C.
 When this condition is true, SI is quiesced, and the value at PIF RAM offset
 $4C is or'd with $40 and stored back.
 Finally, the boot code is executed from its location in RSP DMEM.
\end_layout

\begin_layout Subsubsection
Program header
\end_layout

\begin_layout Paragraph
When the bootstrap code (described below) is executed, it eventually jumps
 to a start address to begin execution of the main program module.
 The bootstrap code compatible with the NUS-CIC-6103 and NUS-CIC-6106 lock-out
 chips (FIXME FIXME FIXME semantics) expects the code in a different location
 in memory, and thus the start address must be modified.
 (Does it really expect it? If so, why must it be placed in the cart header?)
\end_layout

\begin_layout Itemize
For NUS-CIC-6103 programs, add 0x100000 to the start address.
\end_layout

\begin_layout Itemize
For NUS-CIC-6106 programs, add 0x200000 to the start address.
\end_layout

\begin_layout Subsubsection
Boot code in RSP DMEM
\end_layout

\begin_layout Itemize
Zero coprocessor exception and timer registers
\end_layout

\begin_layout Itemize
If RDRAM reg C == 0 {
\end_layout

\begin_layout Itemize
store regs passed from PIF ROM to stack
\end_layout

\begin_layout Itemize
t0 := A4700000
\end_layout

\begin_layout Itemize
t2 := A3F80000
\end_layout

\begin_layout Itemize
t3 := A3F00000
\end_layout

\begin_layout Itemize
t4 := A4300000
\end_layout

\begin_layout Itemize
RI_CONFIG_REG = $40 // current control enable (0)
\end_layout

\begin_layout Itemize
Delay 24000 cyclces
\end_layout

\begin_layout Itemize
RI_CURRENT_CONTROL = 0
\end_layout

\begin_layout Itemize
RI_SELECT = $14
\end_layout

\begin_layout Itemize
RI_MODE = 0
\end_layout

\begin_layout Itemize
Delay 12 cycles
\end_layout

\begin_layout Itemize
RI_MODE = $0E (stop T active, stop R active, operating mode 0x2
\end_layout

\begin_layout Itemize
Delay 64 cycles
\end_layout

\begin_layout Itemize
MI_MODE = $010F (set init mode)
\end_layout

\begin_layout Itemize
RDRAM_DELAY = 0x18082838
\end_layout

\begin_layout Itemize
RDRAM_REF_ROW = 0
\end_layout

\begin_layout Itemize
RDRAM_DEVICE_ID = 0x80000000
\end_layout

\begin_layout Itemize
t5 := t6 := t8 := s2 := s7 := 0
\end_layout

\begin_layout Itemize
t7 := t9 := a2 := A3F00000
\end_layout

\begin_layout Itemize
s4 := s6 := a3 := A0000000
\end_layout

\begin_layout Itemize
fp = sp
\end_layout

\begin_layout Itemize
if MI_VERSION != 0x01010101 (io,rac,rsp,rdp) {
\end_layout

\begin_layout Itemize
s0 = $400
\end_layout

\begin_layout Itemize
s1 = $A3F08000
\end_layout

\begin_layout Itemize
}
\end_layout

\begin_layout Itemize
else {
\end_layout

\begin_layout Itemize
s0 = $200
\end_layout

\begin_layout Itemize
s1 = $A3F04000
\end_layout

\begin_layout Itemize
}
\end_layout

\begin_layout Itemize
$168: 
\end_layout

\begin_layout Itemize
*(s1+4) = 0
\end_layout

\begin_layout Itemize
s5 = &RDRAM_MODE // for $778 func?
\end_layout

\begin_layout Itemize
if (call($778) != 0) { // else goto $25C
\end_layout

\begin_layout Itemize
tmp1 = ret
\end_layout

\begin_layout Itemize
MI_MODE = 0x2000 // RDRAM reg mode
\end_layout

\begin_layout Itemize
tmp2 := t3 := RDRAM_CONFIG & 0xf0ff0000
\end_layout

\begin_layout Itemize
MI_MODE = 0x1000 // clear RDRAM reg
\end_layout

\begin_layout Itemize
if (tmp2 == 0xB0190000) {
\end_layout

\begin_layout Itemize
t8 += 0x08000000
\end_layout

\begin_layout Itemize
t9 += s0*2 (either $200 or $400 depending on version)
\end_layout

\begin_layout Itemize
s4 = s6 = A0200000 // 2MB RAM
\end_layout

\begin_layout Itemize
s2 = 1
\end_layout

\begin_layout Itemize
}
\end_layout

\begin_layout Itemize
else {
\end_layout

\begin_layout Itemize
s4 = A0100000 // 1MB RAM
\end_layout

\begin_layout Itemize
} //RDRAM_CONFIG
\end_layout

\begin_layout Itemize
MI_MODE = 0x2000 // RDRAM reg mode
\end_layout

\begin_layout Itemize
t1 = RDRAM_DEVICE_MANUF & 0xffff
\end_layout

\begin_layout Itemize
k0 = RDRAM_CONFIG
\end_layout

\begin_layout Itemize
MI_MODE = 0x1000 // clear RDRAM reg
\end_layout

\begin_layout Itemize
if (t1 == 0x500 && (k0 & 0x01000000) == 0 ) {
\end_layout

\begin_layout Itemize
RDRAM_RAS_INTERVAL = 0x101c0a04
\end_layout

\begin_layout Itemize
}
\end_layout

\begin_layout Itemize
else {
\end_layout

\begin_layout Itemize
RDRAM_RAS_INTERVAL = 0x080c1204
\end_layout

\begin_layout Itemize
}
\end_layout

\begin_layout Itemize
t6 += 0x08000000
\end_layout

\begin_layout Itemize
t7 += s0*2
\end_layout

\begin_layout Itemize
if ++t5 < 8 goto $168
\end_layout

\begin_layout Itemize
}
\end_layout

\begin_layout Itemize
$25C:
\end_layout

\begin_layout Itemize
A3F8000C = 0xC4000000
\end_layout

\begin_layout Itemize
A3F80004 = 0x80000000
\end_layout

\begin_layout Itemize
sp = fp
\end_layout

\begin_layout Itemize
v1 = 0
\end_layout

\begin_layout Itemize
$274:
\end_layout

\begin_layout Itemize
if (tmp2 == 0xB0090000) { // RDRAM_CONFIG
\end_layout

\begin_layout Itemize
*(s1+4) = t8
\end_layout

\begin_layout Itemize
call($a40)(tmp1, 1)
\end_layout

\begin_layout Itemize
// Confusing code follows, trace in debugger
\end_layout

\begin_layout Itemize
t0 = *s6 // what's s6 here, a load from hw regs?
\end_layout

\begin_layout Itemize
t0 = 0x00080000 // overwrite t0
\end_layout

\begin_layout Itemize
t0 += s6
\end_layout

\begin_layout Itemize
t1 = *t0
\end_layout

\begin_layout Itemize
t0 = *s6 // but s6 hasn't changed
\end_layout

\begin_layout Itemize
t0 = 0x00080000 // overwrite t0
\end_layout

\begin_layout Itemize
t0 += s6
\end_layout

\begin_layout Itemize
t1 = *t0 // but nothing has changed, unless s6 points to volatile
\end_layout

\begin_layout Itemize
t6 += 0x400
\end_layout

\begin_layout Itemize
t9 += s0
\end_layout

\begin_layout Itemize
s6 += 0x10
\end_layout

\begin_layout Itemize
*(s1 + 4) = s7
\end_layout

\begin_layout Itemize
}
\end_layout

\begin_layout Itemize
else {
\end_layout

\begin_layout Itemize
*(s1 + 4) = s7
\end_layout

\begin_layout Itemize
s5 = a2 + 12
\end_layout

\begin_layout Itemize
call($a40)(tmp1, 1)
\end_layout

\begin_layout Itemize
t0 = *a3 (A0000000?) // uncached ram
\end_layout

\begin_layout Itemize
t0 = a3 + 0x8 //overwrite?
\end_layout

\begin_layout Itemize
t1 = *t0
\end_layout

\begin_layout Itemize
t0 = *a3 (A0000000?) // uncached ram
\end_layout

\begin_layout Itemize
t0 = a3 + 0x10 //overwrite?
\end_layout

\begin_layout Itemize
t1 = *t0
\end_layout

\begin_layout Itemize
t0 = *a3 (A0000000?) // uncached ram
\end_layout

\begin_layout Itemize
t0 = a3 + 0x18 //overwrite?
\end_layout

\begin_layout Itemize
t1 = *t0
\end_layout

\begin_layout Itemize
t0 = *a3 (A0000000?) // uncached ram
\end_layout

\begin_layout Itemize
t0 = a3 + 0x8 //overwrite?
\end_layout

\begin_layout Itemize
t1 = *t0
\end_layout

\begin_layout Itemize
t0 = *a3 (A0000000?) // uncached ram
\end_layout

\begin_layout Itemize
t0 = a3 + 0x10 //overwrite?
\end_layout

\begin_layout Itemize
t1 = *t0
\end_layout

\begin_layout Itemize
t0 = *a3 (A0000000?) // uncached ram
\end_layout

\begin_layout Itemize
t0 = a3 + 0x18 //overwrite?
\end_layout

\begin_layout Itemize
t1 = *t0
\end_layout

\begin_layout Itemize
s7 += 0x800
\end_layout

\begin_layout Itemize
a2 += s0*2
\end_layout

\begin_layout Itemize
a3 += 0x20
\end_layout

\begin_layout Itemize
v1++
\end_layout

\begin_layout Itemize
if (v1 < t5) goto $274
\end_layout

\begin_layout Itemize
s2 <<= 19
\end_layout

\begin_layout Itemize
*A4700010 = 0x00063634 | s2
\end_layout

\begin_layout Itemize
t1 = *A4700010 // ??? overwrites with this read, then gets overwritten again
\end_layout

\begin_layout Itemize
*A0000318 = s6 & 0x0FFFFFFF; // osMemSize!
\end_layout

\begin_layout Itemize
sp = fp
\end_layout

\begin_layout Itemize
load s3,s4,s5,s6,s7 from stack
\end_layout

\begin_layout Itemize
store i-cache tag 0/0 for 16k of main memory in 32 byte chunks starting
 at 0x80000000
\end_layout

\begin_layout Itemize
store d-cache tag 0/0 for 8k of main memory in 16 byte chunks starting at
 0x80000000
\end_layout

\begin_layout Itemize
} // tmp2 == 0xB0090000
\end_layout

\begin_layout Itemize
} // call($778)
\end_layout

\begin_layout Itemize
} // reg 0c == 0
\end_layout

\begin_layout Itemize
else {
\end_layout

\begin_layout Itemize
(maybe if this was a soft reset?), invalidate 512 32-byte i-cache lines
 and 512 16-byte d-cache lines in RDRAM // why invalidate d-cache here but
 store tag 0/0 for dcache above?
\end_layout

\begin_layout Itemize
}
\end_layout

\begin_layout Itemize
$458:
\end_layout

\begin_layout Itemize
Copy routine at $4C0-$774 in bootcode (lockout finale and program loader)
 to uncached RAM, address zero, and jump to it
\end_layout

\begin_layout Itemize
sub $778-$87c {
\end_layout

\begin_layout Itemize
save regs to stack and call $880
\end_layout

\begin_layout Itemize
} // sub $778
\end_layout

\begin_layout Itemize
sub $880-$904 {
\end_layout

\begin_layout Itemize
t1 = t3 = t4 = 0
\end_layout

\begin_layout Itemize
for (t4 = 0; t4 < 64;) {
\end_layout

\begin_layout Itemize
v0 = 0
\end_layout

\begin_layout Itemize
call($90C)
\end_layout

\begin_layout Itemize
a0 = t4
\end_layout

\begin_layout Itemize
if (v0 > 0) {
\end_layout

\begin_layout Itemize
k0 = lo((v0 - t1) * t4)
\end_layout

\begin_layout Itemize
t1 = v0
\end_layout

\begin_layout Itemize
t3 += k0
\end_layout

\begin_layout Itemize
}
\end_layout

\begin_layout Itemize
t4++
\end_layout

\begin_layout Itemize
if (t1 >= 0x50) continue
\end_layout

\begin_layout Itemize
a0 = (t3 * 4) - t3
\end_layout

\begin_layout Itemize
a0 *= 4;
\end_layout

\begin_layout Itemize
a0 -= t3;
\end_layout

\begin_layout Itemize
a0 *= 2;
\end_layout

\begin_layout Itemize
a0 -= 880
\end_layout

\begin_layout Itemize
call($980)(a0, a1, s5)
\end_layout

\begin_layout Itemize
break
\end_layout

\begin_layout Itemize
} // loop t4
\end_layout

\begin_layout Itemize
} // sub $880
\end_layout

\begin_layout Itemize
sub $90c-$978 {
\end_layout

\begin_layout Itemize
v0 = 0
\end_layout

\begin_layout Itemize
a1 = 2
\end_layout

\begin_layout Itemize
call ($a40)
\end_layout

\begin_layout Itemize
for (fp = 0; fp < 10; fp++) {
\end_layout

\begin_layout Itemize
*(s4 + 4) = 0x0000ffff
\end_layout

\begin_layout Itemize
v1 = *(s4 + 4) 
\end_layout

\begin_layout Itemize
*s4 = 0x0000ffff
\end_layout

\begin_layout Itemize
*s4 = 0x0000ffff
\end_layout

\begin_layout Itemize
gp = 0
\end_layout

\begin_layout Itemize
v1 >>= 16
\end_layout

\begin_layout Itemize
while ((v1 & 1) && gp++ < 8, v1 >>= 1) {
\end_layout

\begin_layout Itemize
v0++
\end_layout

\begin_layout Itemize
}
\end_layout

\begin_layout Itemize
} // fp loop
\end_layout

\begin_layout Itemize
} // sub $90c
\end_layout

\begin_layout Itemize
sub $980-$a38 {
\end_layout

\begin_layout Itemize
// TO BE CONTINUED
\end_layout

\begin_layout Itemize
} // sub $980
\end_layout

\begin_layout Itemize
sub $a40-$ac8 (a0, a1, s5) {
\end_layout

\begin_layout Itemize
a0 &= 0xff
\end_layout

\begin_layout Itemize
a0 ^= 0x3f
\end_layout

\begin_layout Itemize
t7 = 0x46000000
\end_layout

\begin_layout Itemize
if (a1 == 1) {
\end_layout

\begin_layout Itemize
t7 |= 0x80000000
\end_layout

\begin_layout Itemize
}
\end_layout

\begin_layout Itemize
t7 |= (a0 & 1) << 6
\end_layout

\begin_layout Itemize
t7 |= (a0 & 2) << 13
\end_layout

\begin_layout Itemize
t7 |= (a0 & 4) << 20
\end_layout

\begin_layout Itemize
t7 |= (a0 & 8) << 4
\end_layout

\begin_layout Itemize
t7 |= (a0 & 0x10) << 11
\end_layout

\begin_layout Itemize
t7 |= (a0 & 0x20) << 18
\end_layout

\begin_layout Itemize
*s5 = t7
\end_layout

\begin_layout Itemize
if (a1 == 1) {
\end_layout

\begin_layout Itemize
*MI_MODE = 0
\end_layout

\begin_layout Itemize
}
\end_layout

\begin_layout Itemize
} // sub $a40
\end_layout

\begin_layout Itemize
sub $ad0-$b64 (a0, s5) {
\end_layout

\begin_layout Itemize
MI_MODE = 0x2000 // MI set RDRAM
\end_layout

\begin_layout Itemize
load *s5
\end_layout

\begin_layout Itemize
MI_MODE = 0x1000 // MI clear RDRAM
\end_layout

\begin_layout Itemize
k0 = (*s5 & 0x40) << 6
\end_layout

\begin_layout Itemize
k0 |= (*s5 & 0x4000) << 13
\end_layout

\begin_layout Itemize
k0 |= (*s5 & 0x00400000) << 20
\end_layout

\begin_layout Itemize
k0 |= (*s5 & 0x80) << 4
\end_layout

\begin_layout Itemize
k0 |= (*s5 & 0x8000) << 11
\end_layout

\begin_layout Itemize
k0 |= (*s5 & 0x00800000) << 18
\end_layout

\begin_layout Itemize
msb(*a0) = k0 & 0xff;
\end_layout

\begin_layout Itemize
} // sub $ad0
\end_layout

\begin_layout Itemize
followed by unknown stuff at $b70-$fec
\end_layout

\begin_layout Subsubsection
Boot code in RAM
\end_layout

\begin_layout Standard
This code comes from $4C0-$774 in the 6102 bootcode and executes from RDRAM
 location zero where it has been copied to.
\end_layout

\begin_layout Standard
*A4600000 (PI DRAM_ADDR) = 3rd word of Cart header (start address?) & 0x1FFFFFFF
\end_layout

\begin_layout Standard
while ((*A4600010 & 2 )) { loop } // wait for PI no I/O busy
\end_layout

\begin_layout Standard
*A4600004 = 0x10001000 // PI DMA cart address
\end_layout

\begin_layout Standard
*A460000C = 0x000FFFFF // PI DMA write length (1MB)
\end_layout

\begin_layout Standard
do { wait 28 cycles } while ((*A4600010 & 1)) // wait for PI no DMA busy
\end_layout

\begin_layout Standard
a0 = 3rd word of cart header (boot address)
\end_layout

\begin_layout Standard
a1 = s6 * 0x5D588B65
\end_layout

\begin_layout Standard
ra to stack, s0 to stack
\end_layout

\begin_layout Standard
ra = 0x00100000 // length to checksum over starting at cart header
\end_layout

\begin_layout Standard
t1 = a0
\end_layout

\begin_layout Standard
start checksum loop {
\end_layout

\begin_layout Standard
v0 = *t1 // pick up next word in program code?
\end_layout

\begin_layout Standard
math stuff
\end_layout

\begin_layout Standard
} // checksum loop
\end_layout

\begin_layout Standard
if a3 != *0xB0000010 // 5th word of cart header checksum?
\end_layout

\begin_layout Standard
jump to garbage
\end_layout

\begin_layout Standard
if s0 != *0xB0000014 // 6th word of cart header checksum?
\end_layout

\begin_layout Standard
jump to garbage
\end_layout

\begin_layout Standard
690:
\end_layout

\begin_layout Standard
// OS setup
\end_layout

\begin_layout Standard
// TO BE COMPLETED
\end_layout

\begin_layout Subsubsection
Program code
\end_layout

\begin_layout Paragraph
Once the bootstrap code has transferred execution to our main program module,
 we are mostly in business.
 There is one remaining task to perform before we do anything else, and
 that is to OR the address 0xBFC007FC with 0x08.
 This address is located at the end of the PIF RAM, and it enables the soft-rese
t/NMI generation of the console's reset button.
 If this is not performed, the console will automatically reset in a few
 seconds.
 (FIXME WHY?)
\end_layout

\begin_layout Paragraph
There is one snag we might encounter, and that is that the PIF ROM has only
 transferred the first 1MB of our program image to RAM.
 If the program code is larger than 1MB, then we must execute a PI DMA ourselves
 to transfer its remainder.
 This situation may manifest itself as seemingly random crashes on large
 projects, because the CPU will eventually jump to a program address that
 has not yet been loaded into RAM.
\end_layout

\begin_layout Subsubsection
Boot emulators
\begin_inset LatexCommand label
name "sub:Boot-emulators"

\end_inset


\end_layout

\begin_layout Standard
key - dont trash the structures that the PIF ROM sets up.
 (true?) This is why early 6105 boot emulators had problems determining
 whether a memory expansion pack was installed or not.
\end_layout

\begin_layout Standard
- detect boot code of cart image
\end_layout

\begin_layout Standard
- write proper cic value to $22
\end_layout

\begin_layout Standard
- jump to game's boot code (or is it start address?)
\end_layout

\begin_layout Standard
can we instead simply:
\end_layout

\begin_layout Standard
- pi dma 1mb of program into ram
\end_layout

\begin_layout Standard
- jump to start address
\end_layout

\begin_layout Subsubsection
Soft resetting
\end_layout

\begin_layout Subsubsection
Other notes
\end_layout

\begin_layout Paragraph
FIXME There is a fixed memory location somewhere that can be used to preserve
 64-bytes of information across a NMI/soft reset but not a hard reset.
 (osAppNMIBuffer).
 Also, anything outside of the 1MB boot segment will remain untouched after
 a soft reboot.
\end_layout

\begin_layout Section
Setting up GNU Binutils for N64
\end_layout

\begin_layout Subsection
Introduction
\end_layout

\begin_layout Paragraph
We will be developing for N64 using the free GNU toolchain and a Debian
 GNU/Linux host machine.
 The basic components of a toolchain are the utilities used to manipulate
 object files of machine language code, such as an assembler, a linker,
 a librarian/archiver, a profiler, and programs to copy to and from various
 object formats and to examine symbols within a particular object file.
 Later, we will add C and C++ compilers, standard C/C++ libraries, and a
 source-level debugger to complete the toolchain.
\end_layout

\begin_layout Paragraph
GNU Binutils can be downloaded at:
\end_layout

\begin_layout Itemize
http://sources.redhat.com/binutils/
\end_layout

\begin_layout Paragraph
The most recent binutils release as of this writing is 2.15 (May 2004).
\end_layout

\begin_layout Paragraph
Note that Debian provides a package named 'toolchain-source' that can expedite
 building a set of toolchain packages from scratch.
 This is typically an easier but less universal approach.
 Occasionally toolchain-source becomes unmaintained and out-of-date, so
 building from the upstream sources may be preferable in those cases.
\end_layout

\begin_layout Subsection
Configuring and Building Binutils
\end_layout

\begin_layout Paragraph
Once we have downloaded the file (in bzip2 format), execute the following
 commands to unpack it and change into its directory:
\end_layout

\begin_layout Itemize
$ tar jxf binutils-2.15.tar.bz2
\end_layout

\begin_layout Itemize
$ cd binutils-2.15
\end_layout

\begin_layout Paragraph
Next, we will configure the package for building.
 First, we need to define a few standard options for building the toolchain.
\end_layout

\begin_layout Itemize
Build system
\newline
The type of system that the package is being built on.
\end_layout

\begin_layout Itemize
Host system
\newline
The type of system that the built package will run on.
\end_layout

\begin_layout Itemize
Target system
\newline
The type of system that the built package will produce object
 code for.
\end_layout

\begin_layout Paragraph
Usually, and especially in this case, the Build and Host systems will be
 the same.
 We are building the package on an i386 host to execute on an i386 host,
 and those will be automatically detected by the configure process.
 However, the target system is our N64.
 
\end_layout

\begin_layout Paragraph
The toolchain configuration options expect a canonical system name.
 We can use the included 'config.guess' script to find the canonical system
 name of the host, but since we cannot run this script on the target, we
 must reasonably guess a canonical system name for the target.
\end_layout

\begin_layout Paragraph
A canonical system name is comprised of the following components, separated
 by dashes:
\end_layout

\begin_layout Enumerate
Hardware architecture (including endianness)
\end_layout

\begin_layout Enumerate
System vendor (or 'unknown', or nothing)
\end_layout

\begin_layout Enumerate
Operating system or object file format
\end_layout

\begin_layout Paragraph
For our N64, the hardware architecture is 'mips' (little endian would be
 'mipsel').
 For discussion of 64-bit issues, see 
\begin_inset LatexCommand ref
reference "sub:64-Bit-Issues"

\end_inset

.
 We don't really need to worry about them right now except that our toolchain
 should be configured as 'mips64' and not 'mips'.
\end_layout

\begin_layout Paragraph
The system vendor should be 'unknown' since the GNU toolchain has no pre-existin
g support for it.
 However, it turns out that we need the system vendor to be 'linux' in order
 to (coupled with 'mips64' arch) obtain a toolchain capable of using the
 desired 'n32' ABI (see 
\begin_inset LatexCommand ref
reference "sub:64-Bit-Issues"

\end_inset

).
\end_layout

\begin_layout Paragraph
rem Since we are not building object code to run under an operating system,
 we could define an object file format instead.
 We will use ELF (Executable and Linkable Format), which is 'elf' in the
 canonical name.
 ELF is a suitably flexible object format in general, but using ELF means
 that our toolchain will also be compatible with the official SDK libraries,
 which are in ELF format.
 A licensed developer might wish to use a toolchain built here to build
 a program with code from the official SDK.
\end_layout

\begin_layout Paragraph
Putting the pieces together, we have:
\end_layout

\begin_layout Itemize
mips64-linux
\end_layout

\begin_layout Itemize
or
\end_layout

\begin_layout Itemize
mips-unknown-linux-elf
\end_layout

\begin_layout Paragraph
Our configure command is thus:
\end_layout

\begin_layout Itemize
./configure --prefix=/usr/local/n64 --program-prefix=n64- --target=mips64-linux
\end_layout

\begin_layout Paragraph
We define a program-prefix for the programs in our N64 toolchain, so that
 our binaries do not have name conflicts with any other toolchain already
 on the system.
\end_layout

\begin_layout Paragraph
After Binutils is configured, simply issue 'make' to complete the build.
 If there are no errors, issue 'make install', and the fundamental pieces
 of our toolchain will have been installed in /usr/local/n64.
\end_layout

\begin_layout Subsection
Binutils Components
\end_layout

\begin_layout Itemize
n64-ar - Archiver, for combining object files into libraries
\end_layout

\begin_layout Itemize
n64-as - Assembler, to encode assembly source files into machine instructions
\end_layout

\begin_layout Itemize
n64-ld - Linker, to combine separate object files into a program and resolve
 symbol references between objects
\end_layout

\begin_layout Itemize
n64-nm - Lists symbols and interfaces in object files
\end_layout

\begin_layout Itemize
n64-objcopy - Translates between different object file formats
\end_layout

\begin_layout Itemize
n64-objdump - Display information about an object file, including its disassembl
y
\end_layout

\begin_layout Itemize
n64-ranlib - Create symbol index in a library
\end_layout

\begin_layout Itemize
n64-size - Display size of object file sections
\end_layout

\begin_layout Itemize
n64-strings - Search object for NUL-terminated ASCII strings
\end_layout

\begin_layout Itemize
n64-strip - Remove profiling information, debugging information, and/or
 symbols from an object
\end_layout

\begin_layout Paragraph
Our exposure to these tools will primarily be limited to ar, as, ld, objdump,
 and strip.
 However, all of these tools are useful in various circumstances, since
 they are nearly the only resources we have to easily manipulate binary
 object files.
\end_layout

\begin_layout Subsection
Using Binutils
\end_layout

\begin_layout Paragraph
You can add the N64 toolchain to your executable search path:
\end_layout

\begin_layout Itemize
$ PATH=$PATH:/usr/local/n64/bin
\end_layout

\begin_layout Paragraph
Then, for example to invoke the assembler, you can just type 'n64-as' instead
 of '/usr/local/n64/bin/n64-as'.
\end_layout

\begin_layout Paragraph
Assemble the following test program, passing -mips3 to the assembler.
 This will verify that the assembler works as expected:
\end_layout

\begin_layout Standard
FIXME
\end_layout

\begin_layout Paragraph
For developing your own programs in assembly language, see the 
\begin_inset Quotes eld
\end_inset

The MIPS64 Architecture For Programmers
\begin_inset Quotes erd
\end_inset

 volumes I and II.
\end_layout

\begin_layout Section
Bootstrapping the Development Environment
\end_layout

\begin_layout Subsection
Building a N64 Program Image
\end_layout

\begin_layout Subsubsection
Header
\end_layout

\begin_layout Subsubsection
Boot Code
\end_layout

\begin_layout Subsubsection
Checksum
\end_layout

\begin_layout Standard
ld script
\end_layout

\begin_layout Section
Using and Extending a Hardware Simulator 
\end_layout

\begin_layout Paragraph
The multi-system emulator GXemul (0.4.6.3)
\end_layout

\begin_layout Standard
- useful for fast prototyping
\end_layout

\begin_layout Standard
cheaper than dedicated simulation hw (INDY device or PSY-Q SCSI thing
\end_layout

\begin_layout Standard
requires a fast CPU to simulate the target in realtime
\end_layout

\begin_layout Standard
must emulate peripherals in software
\end_layout

\begin_layout Standard
does not require boot rom from N64, since we have existing boot emulators
 to work from
\end_layout

\begin_layout Standard
Can be incrementally developed by attempting to run known-working software
 and filling in what is missing one piece at a time.
 Real machines have to be built according to specifications and tested for
 adherence to them.
\end_layout

\begin_layout Itemize
src/devices - Drivers for emulated hardware components
\end_layout

\begin_layout Itemize
src/machines - Initialization and definitions for a particular system
\end_layout

\begin_layout Itemize
src/prom - Emulation of system state after boot ROM has executed
\end_layout

\begin_layout Paragraph
In src/machines/machine_n64.c:
\end_layout

\begin_layout Itemize
Build memory map
\end_layout

\begin_layout Itemize
Register device emulators with IRQ machine[0].cpu[0].X (2-6)
\end_layout

\begin_layout Itemize
Emulate PIF ROM (and possibly boot-code for inserted cart) if user has not
 provided PIF ROM
\end_layout

\begin_layout Paragraph
General gxemul setup
\end_layout

\begin_layout Itemize
Edit src/include/machine.h and add a new define for your system to be used
 in MACHINE_REGISTER(x)
\end_layout

\begin_layout Itemize
Create a new CPU entry (R4300) according to those defined in src/include/mips_cp
u_types.h; use R4000 as a template and refer to cpu_mips.h.
 (Cache sizes in mips_cpu_types.h are powers of 2.)
\end_layout

\begin_layout Itemize
Add code to initialize cop0 for the R4300 into src/cpus/cpu_mips_coproc.c
\end_layout

\begin_layout Paragraph
In src/devices/dev_n64_rcp.c:
\end_layout

\begin_layout Itemize
Implement memory access, tick, and interrupt routines for all system devices
\end_layout

\begin_layout Itemize
Register all devices with gxemul
\end_layout

\begin_layout Itemize
Instantiate devices from machine_n64.c with string arguments for I/O range
 and interrupts
\end_layout

\begin_layout Paragraph
Edit src/devices/Makefile.skel and src/machines/Makefile.skel adding the correspon
ding .o for whatever .c file you created.
 Then ./configure && make.
 ./gxemul -H and you should see your N64 port in the list.
 If you have dumped an image of the PIF/Bootstrap ROM from your N64, you
 can try executing it.
 Otherwise, try executing your own test program that is written according
 to this manual.
 Fill in hardware functionality as required.
\end_layout

\begin_layout Standard
Make sure the bootstrap rom is the last ROM specified if PROM emulation
 is not implemented or disabled.
\end_layout

\begin_layout Standard
gxemul -En64 -viJQT 0xffffffffb0000000:DX-BE12B.ROM 0xffffffffbfc00000:pifntsc.raw
\end_layout

\begin_layout Section
Building A C/C++ Toolchain
\end_layout

\begin_layout Subsection
64-Bit Issues
\begin_inset LatexCommand label
name "sub:64-Bit-Issues"

\end_inset


\end_layout

\begin_layout Paragraph
The N64 CPU is capable of using its general purpose registers in 64-bit
 mode by setting a CPU flag.
 However, just doing this does not provide any advantage to software, since
 the compiler may not be emitting instructions that utilize 64-bit registers.
 The question is, under what circumstances do we wish to actually utilize
 64-bit code?
\end_layout

\begin_layout Paragraph
64-bit code does not necessarily run faster than 32-bit code.
 64-bit register loads take more instructions, increasing the storage size
 of the executable code and decreasing cache efficiency.
 64-bit constants also increase the size of the executable code.
 So we want to only emit 64-bit code when it makes sense for our application.
\end_layout

\begin_layout Paragraph
First of all, it would be nonsense to use 64-bit pointers in the N64, since
 its entire memory map, including hardware, fits in a 32-bit address space.
\end_layout

\begin_layout Paragraph
Since the GNU C compiler fixes the default size of the pointer to be equal
 to the size of the long, it would be more convenient to have 32-bit longs,
 because then we would not have to explicitly declare pointers to be 32-bit.
\end_layout

\begin_layout Paragraph
The base of existing open source software typically assumes that a long
 is 32 bits, since that's what most machines today use.
 So this choice would also eliminate issues of porting third-party code
 to the N64.
\end_layout

\begin_layout Paragraph
We thus have several advantages to choosing a ILP32 (integer/long/pointer
 = 32-bit) target over a LP64 (long, pointer = 64-bit) target.
 Furthermore, we can still utilize 64-bit integers in any special cases
 by using the 'long long' type and passing -mips3 to the compiler (enabling
 MIPS III ISA, required for instructions that utilize 64-bit registers).
\end_layout

\begin_layout Paragraph
The next challenge will be to choose an ABI (Application Binary Interface).
 The ABI essentially defines the size of C data types as well as establishing
 a convention for function calls with respect to what arguments are passed
 in registers, what is passed on the stack and where on the stack it is
 located, and where to find the function's return value.
 An ABI is what allows us to link object modules together and expect them
 to work.
 We will also need to respect the ABI when mixing C modules with pure assembly
 modules (usually C modules with inline assembly are more convenient).
\end_layout

\begin_layout Paragraph
MIPS defines four ABIs - 'o32', 'n32', 'o64', and 'n64', where the 'o' means
 'old' and the 'n' means 'native', and where the default 32-bit ABI is 'o32'
 and the default 64-bit ABI is 'n64'.
 (The name is a coincidence.) The 'o32' ABI is the first MIPS ABI.
 It is ILP32 and only MIPS I/II instructions are allowed.
 It also allows only 16 floating point registers to be used, hampering modern
 FP coprocessors.
 The 'o64' ABI is obsolete and irrelevant for this discussion.
 The 'n64' ABI was the 64-bit ABI that replaced 'o32'.
 It is LP64, allows 32 FP registers to be used, and allows MIPS III/IV instructi
ons.
 However, this ABI has all the disadvantages of 64-bit architectures noted
 above.
 As a compromise, the 'n32' ABI was developed.
 Like the 'n64' ABI, it allows 32 FP registers as well as MIPS III/IV instructio
ns.
 However, it is ILP32, which turns out to be much more efficient on an embedded
 system like the N64.
\end_layout

\begin_layout Paragraph
So we will want to build our application code with a 'n32' ABI, which is
 done by specifying -mabi=n32 to the GNU compiler.
 This implies the -mips3 option.
 (The GNU compiler's default is to compile for MIPS I and the 'o32' [-mabi=32]
 ABI.
 If the toolchain is configured as noted below, the 'n32' ABI will be the
 default.)
\end_layout

\begin_layout Paragraph
The proprietary Nintendo ELF libraries are built for MIPS II with the 'o32'
 ABI.
 If you want to link your code with the Nintendo libraries, you will need
 to compile your code with the -mips2 option (which implies -mabi=32, for
 'o32').
\end_layout

\begin_layout Paragraph
For a GNU configure tuple, the 'mips' target implies a default 'o32' ABI.
 The problem with configuring like this is that 'n32' isn't then even available
 as a target ABI.
 Current binutils (2.15) requires a mips64-linux target in order for the
 'n32' ABI to be enabled, and in which case, it will become the default.
 So we will use 'mips64' as the architecture and 'linux' as the system vendor,
 even though neither particularly makes sense in this scenario.
\end_layout

\begin_layout Paragraph
Remember that if you are using functions written in assembly language, you
 must obey the ABI that your application is using.
 It would also be a good idea to assemble with the appropriate -mips[1-4]
 and -mabi=? options, so that the assembler can verify that you haven't
 accidentally used an instruction that is invalid for the ABI and ISA that
 you are using.
 You can find the information on the 'n32' ABI in the following document:
 
\begin_inset Quotes eld
\end_inset

MIPSpro N32 ABI Handbook
\begin_inset Quotes erd
\end_inset

 (SGI document number: 007-2816-005).
\end_layout

\begin_layout Paragraph
Note: Instead of using -mips3 when compiling, you can use -march=vr4300.
 This option implies -mips3, additionally enables any tuning for that specific
 CPU, and doesn't work around errata not present in that CPU like a generic
 -mips[1-4] option would.
 (A generic option like -mips3 must support any CPU that implements that
 ISA level, no matter what bugs it has, so that option will implement a
 union of all workarounds for CPUs implementing that ISA level.) We can use
 this CPU-specific option for code targeting the N64, because we know exactly
 what CPU is used on the target, and that our code will never need to run
 on any other CPU.
\end_layout

\begin_layout Subsection
Building the GNU C Compiler Without A Target OS
\end_layout

\begin_layout Paragraph
We will be building what is known as a 'bootstrap' C compiler.
 It does not have support for threads or shared libraries.
 However, it does not require a C library, which at this point is the situation
 we are in.
 We will also wait until later to build the C++ compiler, since building
 it requires a working C library.
 Once the bootstrap compiler is built, we will use it to build a C library
 that either requires (glibc) or does not require (newlib) an operating
 system.
 Once that C library is built, we will then build a C++ compiler, and also
 rebuild the C compiler, with thread and shared library support if the target
 operating system supports it.
 The C++ compiler and rebuilding of the C compiler can be skipped if there
 is no necessity for those features on the target (e.g., if the bootstrap
 compiler is sufficient to produce the application code for the target).
\end_layout

\begin_layout Standard
./configure --prefix=/afs/icequake.net/dist/arch/i386_linux24/toolchain --program-
prefix=n64- --target=mips64-linux --disable-threads --disable-nls --disable-shar
ed --enable-languages=c --without-headers --with-newlib 
\end_layout

\begin_layout Section
Building A Reusable Library of Functionality
\end_layout

\begin_layout Standard
host - general functions + includes with constants + host specific functions
\end_layout

\begin_layout Standard
target - general functions + includes with constants + target specific functions
 (communications slave, inline asm, etc)
\end_layout

\begin_layout Section
Performance Evaluation and Benchmarking
\end_layout

\begin_layout Subsection
Bottlenecks
\end_layout

\begin_layout Subsubsection
Video
\end_layout

\begin_layout Paragraph
While the N64's graphics hardware is reasonably fast, it is still not very
 competitive even with the Sony PlayStation which was released nearly two
 years ahead of it.
 The two video bottlenecks are:
\end_layout

\begin_layout Itemize
Triangle throughput
\end_layout

\begin_layout Paragraph
The N64 has a claimed 150,000 fully lit and transformed polygons per second
 throughput.
 While this sounds like a lot, it really isn't, especially in complex scenes.
 At 30fps, that is only 5,000 polygons per frame.
 Using flat or gourad shading can help this throughput.
 We don't know if this number includes texture mapping, so we will test
 this.
 Note that if the RSP is being used for audio processing, polygon throughput
 will suffer; not only will the RSP be dividing its computation time between
 two tasks, but the RSP microcode must also be reloaded every time it changes
 duties.
\end_layout

\begin_layout Itemize
Texture memory
\end_layout

\begin_layout Paragraph
The RDP has 4KB of texture memory, which is precisely enough for one 32x32
 32-bit RGBA texture.
 We can make more efficient use of this memory by using smaller textures
 or scaling down the color depth, but image quality will suffer.
 Unfortunately, we cannot avoid thrashing on such a small amount of memory,
 so we must be creative with our texture usage.
\end_layout

\begin_layout Subsubsection
Audio Hardware
\end_layout

\begin_layout Paragraph
The N64 AI (Audio Interface) is only a very simplistic audio processor,
 compared to the competing Sega Saturn and Sony PlayStation.
 It has a set of registers which, at any time, can have at most one sample
 queued while playing one sample from memory.
 Samples can be 4 to 16-bit, up to 48KHz, raw or ADPCM format.
 Any mixing, synthesis, or effects processing must be done by the CPU or
 RSP in real-time, at an incremental performance cost for each channel or
 effect in use.
\end_layout

\begin_layout Subsubsection
Unified Memory
\end_layout

\begin_layout Paragraph
The N64's unified memory architecture, while convenient to program, presents
 an additional performance issue: peripherals must contend for memory access.
 When only using one peripheral at a time, this should not be a problem
 at all.
 But consider this scenario: we are playing a sound buffer on the AI, and
 a PI DMA is performed to transfer more sound or model data into memory,
 while the RSP writes a RDP command list to a FIFO buffer in memory, and
 the RDP reads from that buffer and writes to the back framebuffer...
 and on top of that, the VI must read the entire contents of the the front
 framebuffer up to 60 times per second in order to refresh the display!
\end_layout

\begin_layout Paragraph
This sounds like a contrived scenario, but it really is not; this is what
 is going on inside the N64 at all times when a typical game program is
 running.
 The problem is that we could spend years trying to optimize each line of
 code to ensure that hardware does not waste time waiting on memory access,
 but that would most likely yield only a marginal improvement compared to
 the amount of time spent on execution analysis trials.
 Instead, we will try to single out some worst-case memory access patterns
 through benchmarking, and optimize out those cases in library code so that
 all applications will benefit.
\end_layout

\begin_layout Subsection
Benchmark Design
\end_layout

\begin_layout Section
Porting RedBoot/eCos
\end_layout

\begin_layout Standard
RedBoot can be used as a general purpose debug loader, or specifically as
 a Linux bootloader.
\end_layout

\begin_layout Section
Porting Linux
\end_layout

\begin_layout Subsection
The kernel
\end_layout

\begin_layout Subsubsection
ucLinux
\end_layout

\begin_layout Paragraph
Kernel messages -> screen, or debug stub (gameshark, cd64, z64, etc)
\end_layout

\begin_layout Subsubsection
framebuffer
\end_layout

\begin_layout Subsubsection
startup code
\end_layout

\begin_layout Standard
Interrupts: Linux-MIPS porting guide
\end_layout

\begin_layout Subsection
Userland
\end_layout

\begin_layout Subsubsection
cramfs
\end_layout

\begin_layout Subsubsection
busybox (as init replacement)
\end_layout

\begin_layout Subsubsection
newlib
\end_layout

\begin_layout Subsubsection
dynamically linked busybox
\end_layout

\begin_layout Subsection
Drivers
\end_layout

\begin_layout Subsubsection
Input
\end_layout

\begin_layout Paragraph
We will support the use of a joystick and/or a hacked mouse.
 Explore keyboard input.
 Force feedback (rumble).
\end_layout

\begin_layout Subsubsection
DirectFB OpenGL
\end_layout

\begin_layout Subsubsection
ALSA Audio
\end_layout

\begin_layout Subsubsection
Cartridge/peripheral interface
\end_layout

\begin_layout Paragraph
On devices with PI registers, we should be able to access the Zip disk or
 CD filesystems transparently, and to use the communications port of peripherals.
 We should have an interface to dump the cart and to write to the PI safely.
\end_layout

\begin_layout Subsubsection
Memory technology devices (cart memory, memory packs)
\end_layout

\begin_layout Subsubsection
Serial interface
\end_layout

\begin_layout Paragraph
Can the controller interface be used as a general serial interface (so we
 can e.g.
 get a terminal or run PPP over an Adaptoid?) We need to find out how to
 get SI interrupts.
\end_layout

\begin_layout Subsubsection
Power management
\end_layout

\begin_layout Paragraph
Is R4300's low power mode supported? Can we enable it when the machine has
 been idle?
\end_layout

\begin_layout Subsection
Userspace code examples
\end_layout

\begin_layout Subsubsection
Universal APIs (OpenGL, ALSA)
\end_layout

\begin_layout Subsubsection
System-specific APIs (cart dumping)
\end_layout

\begin_layout Subsection
Preparing a Linux-N64 program for market
\end_layout

\begin_layout Section
Porting KallistiOS
\end_layout

\begin_layout Section
Complete Hardware Reference 
\end_layout

\begin_layout Section
Peripheral Hardware Reference 
\end_layout

\begin_layout Subsection
UFO/Success CD64
\end_layout

\begin_layout Subsubsection
CD64 Hardware and Operation
\end_layout

\begin_layout Standard
How does it let the cartridge talk for CIC and bootcode, but then override
 the bus to deliver BIOS code when in BIOS mode, but not in 
\begin_inset Quotes eld
\end_inset

Play cart
\begin_inset Quotes erd
\end_inset

 mode?
\end_layout

\begin_layout Subsubsection
Upgrading and Modifying the CD64 Hardware
\end_layout

\begin_layout Subsubsection
Interfacing the CD64 from a N64 program
\end_layout

\begin_layout Standard
Example of writing a replacement CD64 BIOS.
\end_layout

\begin_layout Subsubsection
CD64 PI Register Map
\end_layout

\begin_layout Subsubsection
Communicating with the CD64 BIOS and Ghemor from a PC
\end_layout

\begin_layout Subsection
Mr.
 Backup Z64
\end_layout

\begin_layout Subsubsection
Z64 Hardware and Operation
\end_layout

\begin_layout Standard
HW1/HW2/HW3 differences
\end_layout

\begin_layout Subsubsection
Upgrading and Modifying the Z64 Hardware
\end_layout

\begin_layout Standard
RAM upgrade (512KB -> 1MB)
\end_layout

\begin_layout Standard
HD/Zip250/Orb upgrade
\end_layout

\begin_layout Standard
Connecting IRQ/DMA lines
\end_layout

\begin_layout Standard
NIC/parallel port/commslink/VGA addons
\end_layout

\begin_layout Standard
keyboard connector
\end_layout

\begin_layout Subsubsection
Interfacing the Z64 from a N64 program
\end_layout

\begin_layout Standard
Example of writing a replacement Z64 BIOS.
\end_layout

\begin_layout Subsubsection
Z64 PI Register Map
\end_layout

\begin_layout Subsubsection
Modifying the Z64 Operating System
\end_layout

\begin_layout Subsubsection
Communicating with the Z64 from a PC
\end_layout

\begin_layout Subsection
Bung Doctor V64
\end_layout

\begin_layout Subsubsection
Doctor V64 Hardware and Operation
\end_layout

\begin_layout Subsubsection
Upgrading and Modifying the Doctor V64 Hardware
\end_layout

\begin_layout Subsubsection
Modifying the Doctor V64 Operating System
\end_layout

\begin_layout Subsubsection
Communicating with the Doctor V64 from a PC
\end_layout

\begin_layout Subsection
Bung Doctor V64jr
\end_layout

\begin_layout Subsubsection
Doctor V64jr Hardware and Operation
\end_layout

\begin_layout Subsubsection
Upgrading and Modifying the Doctor V64jr Hardware
\end_layout

\begin_layout Subsubsection
Interfacing the Doctor V64jr from a N64 program
\end_layout

\begin_layout Subsubsection
Communicating with the Doctor V64jr from a PC
\end_layout

\begin_layout Subsection
Valery's PV-Backup
\end_layout

\begin_layout Subsection
Ultra64Pro RAM Card
\end_layout

\begin_layout Standard
8-64MB SDRAM/EDO Battery backup
\end_layout

\begin_layout Standard
PC connection (ECP or USB)
\end_layout

\begin_layout Standard
R/W registers mapped to N64 PI to change mode and N64<->PC comms
\end_layout

\begin_layout Standard
built in save emulation for SRAM, 4K/16K EEP <->controller pak file (compress
 SRAM to fit normal pak) and flashram <->4X controller pak
\end_layout

\begin_layout Standard
BIOS with save management and configuration runs if no file loaded CIC passthrou
gh or emulation
\end_layout

\begin_layout Subsection
Wildcard 64
\end_layout

\begin_layout Subsection
Datel Game Shark Pro
\end_layout

\begin_layout Subsubsection
Loading and Booting N64 Code
\end_layout

\begin_layout Subsubsection
Communicating with the Game Shark from a PC
\end_layout

\begin_layout Subsubsection
Communicating with the PC from a N64 program
\end_layout

\begin_layout Subsection
Wishtech Adaptoid
\end_layout

\begin_layout Subsection
Generic SI<->RS232 adapter (PIC?)
\end_layout

\begin_layout Subsection
Tristar 64
\end_layout

\begin_layout Subsection
GB Hunter/Game Booster 2in1
\end_layout

\begin_layout Subsection
64DD Disk Drive (
\begin_inset Quotes eld
\end_inset

Leo
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Subsection
PSY-Q Development Board and Suite
\end_layout

\begin_layout Subsection
Indy Emulator (Official)
\end_layout

\begin_layout Subsection
N64 Country Adapters (Passport, etc)
\end_layout

\begin_layout Standard
Do they have a program/bootemu or are they only a physical adapter? Semantics
 of booting PAL vs NTSC (lockout chip), PAL-fixing, cart interchangeability
\end_layout

\end_body
\end_document
